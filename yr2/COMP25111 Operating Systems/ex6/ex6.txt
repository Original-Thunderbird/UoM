Allocated 10 pieces of shared memoies,each with a different key and shared memory id; send a message back to send after all information is received by receive.


in send.c:
main (int argc, char *argv[])	// The 'root' programme; execution start
{
int shm_id[10], private, i;
unsigned char* p_shm[10];
pid_t new_PID;				// PID return value from fork
if (argc < 2) printf("Need an argument to send, too.\n");
else{
  for(i=0;i<10;i++){
    p_shm[i] = create_shm(KEY+i, SIZE, &(shm_id[i]));	// Create a shared memory
    printf("Sender's shared memory is at address: %016X\n", p_shm[i]);
    p_shm[i][0] = 0;
  }
  for(i=0;i<argc-1;i++){
      strcpy(p_shm[i] + 1, argv[i+1]);		// Copy argument into shared memory.
      p_shm[i][0] = 1;				// indicate copy complete
  }
while (p_shm[0][0] != 0)  sleep(1);		// Wait
printf("Send: message received.\n");
for(i=0;i<10;i++){
    release_shm(p_shm[i]);			// Free shared memory
}
  }
exit(0);
}

in receive.c:
main (int argc, char *argv[])	// The 'root' programme; execution start
{
int shm_id[10];
unsigned char* p_shm[10];
pid_t new_PID;				// PID return value from fork
for(i=0;i<10;i++){
    p_shm[i] = create_shm(KEY+i, SIZE, &(shm_id[i]));	// Create a shared memory
    printf("Receiver's shared memory is at address: %016X\n", p_shm[i]);
    p_shm[i][0] = 0;				// Flag that message has (not) arrived.
}
while (p_shm[1][0] == 0) sleep(1);		// Poll for message
i=0;
while(p_shm[i][0]){
    printf("Receiver picked up message:: \"%s\"\n", &p_shm[i][1]);
    i++;
}
/* "&p_shm[1]" ?!  The address of (&) character 1 ([1]) in array "p_shm".     */
for(i=0;i<10;i++){
  p_shm[i][0] = 0;				// Message is finished with
}
for(i=0;i<10;i++){
    release_shm(p_shm[i]);		   	// Free shared memory
    destroy_shm(shm_id[i]);			// ... and destroy it
}
exit(0);
}

